---
title: Architecture
---

Fabrik is built around a DDD-inspired architecture designed to keep your Flutter codebase clean, scalable,
and easy to reason about — even as your app grows.

Every feature generated by Fabrik CLI follows a consistent
folder structure, encouraging clear separation of concerns and high testability.

## Folder Structure

**`models/`**

Handles JSON serialization and API contracts, implemented using _`json_serializable`_.
These classes directly reflect the structure of the data coming from or going to your backend.

**`entities/`**

Contains pure domain models, usually implemented with _`freezed`_ or _`equatable`_. These are framework-agnostic and represent your business logic.

**`data_source/`**

Responsible for fetching raw data from APIs, databases, or other sources. This layer has no business logic — just communication.

**`repository/`**

Acts as a bridge between data_source and entities. It maps models to entities, handles failures, and ensures the domain layer stays clean.

**`usecases/`**

Encapsulates individual business rules or operations, like fetching a user or updating a setting. Each use case does one thing and can be tested independently.

**`bloc/`**

Manages UI state and events. Works closely with use cases and uses patterns like Status and Failure to represent transitions.

## Why this Structure?

This architecture is:

- Modular — each piece is replaceable and independent
- Testable — business logic is isolated from UI and infrastructure
- Understandable — new developers can quickly grasp the flow
- Reusable — patterns repeat across all features, reducing onboarding time

This system works well for both solo devs and large teams, and scales elegantly as your codebase grows.
